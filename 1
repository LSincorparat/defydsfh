--[[
    Stratus.xyz Arsenal Premium
    Advanced Roblox Script Hub
    Version: 2.0.0
    Discord: discord.gg/stratusxyz
    Credits: @stratusdev, @xz, @goof
]]

-- Initialize environment
getgenv().Config = {
    Invite = "discord.gg/stratusxyz",
    Version = "2.0.0",
    Settings = {}
}

-- Load UI Library
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/drillygzzly/Other/main/1"))()
library:init()

-- Main Window
local Window = library.NewWindow({
    title = "Stratus.xyz Arsenal Premium",
    size = UDim2.new(0, 600, 0, 700)
})

-- Tab Structure
local tabs = {
    Aimbot = Window:AddTab("Aimbot"),
    Visuals = Window:AddTab("Visuals"),
    Risky = Window:AddTab("Risky"),
    Settings = library:CreateSettingsTab(Window),
}

-- Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local HttpService = game:GetService("HttpService")
local GuiService = game:GetService("GuiService")
local TweenService = game:GetService("TweenService")

-- Local Variables
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()
local Drawing = Drawing or {}
local Heartbeat = RunService.Heartbeat
local RenderStepped = RunService.RenderStepped
local Stepped = RunService.Stepped

-- Shared Tables
local connections = {}
local espCache = {}
local aimbotTarget = nil
local fovCircle = nil
local aimbotActive = false
local espEnabled = false
local radarEnabled = false
local crosshairEnabled = false
local lastTick = tick()
local fps = 0
local frameCount = 0
local watermark = nil

-- Performance Optimizations
local math_floor = math.floor
local math_abs = math.abs
local math_sqrt = math.sqrt
local math_atan2 = math.atan2
local math_cos = math.cos
local math_sin = math.sin
local table_insert = table.insert
local table_remove = table.remove
local Vector3_new = Vector3.new
local CFrame_new = CFrame.new
local Color3_new = Color3.new
local Color3_fromRGB = Color3.fromRGB
local UDim2_new = UDim2.new
local Ray_new = Ray.new
local Instance_new = Instance.new

-- Initialize Drawing Objects
local function InitializeDrawings()
    -- FOV Circle
    fovCircle = Drawing.new("Circle")
    fovCircle.Visible = false
    fovCircle.Thickness = 1
    fovCircle.Color = Color3_fromRGB(255, 255, 255)
    fovCircle.Filled = false
    fovCircle.Transparency = 1
    fovCircle.Radius = 100
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    
    -- Crosshair
    local crosshair = {}
    crosshair.line1 = Drawing.new("Line")
    crosshair.line2 = Drawing.new("Line")
    crosshair.line3 = Drawing.new("Line")
    crosshair.line4 = Drawing.new("Line")
    
    for _, line in pairs(crosshair) do
        line.Visible = false
        line.Thickness = 1
        line.Color = Color3_fromRGB(255, 255, 255)
        line.Transparency = 1
    end
    
    -- Watermark
    watermark = Drawing.new("Text")
    watermark.Visible = false
    watermark.Size = 18
    watermark.Color = Color3_fromRGB(255, 255, 255)
    watermark.Outline = true
    watermark.OutlineColor = Color3_fromRGB(0, 0, 0)
    watermark.Text = "Stratus.xyz | "..(identifyexecutor() or "Unknown").." | FPS: 0"
    watermark.Position = Vector2.new(10, 10)
    
    return {
        fovCircle = fovCircle,
        crosshair = crosshair,
        watermark = watermark
    }
end

local drawings = InitializeDrawings()

-- Utility Functions
local function IsPlayerValid(player)
    return player and player:IsA("Player") and player.Character and player.Character:FindFirstChild("Humanoid") and 
           player.Character:FindFirstChild("HumanoidRootPart") and player.Character.Humanoid.Health > 0
end

local function IsVisible(part)
    if not part then return false end
    local origin = Camera.CFrame.Position
    local _, hit = Workspace:FindPartOnRay(Ray_new(origin, part.Position - origin), LocalPlayer.Character)
    return hit and hit:IsDescendantOf(part.Parent)
end

local function GetClosestPlayerToCursor()
    local closestPlayer = nil
    local shortestDistance = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and IsPlayerValid(player) then
            -- Team check
            if library.flags.Aimbot_TeamCheck and player.Team == LocalPlayer.Team then
                continue
            end
            
            -- Visibility check
            if library.flags.Aimbot_VisibilityCheck and not IsVisible(player.Character.Head) then
                continue
            end
            
            -- Distance check
            local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
            if library.flags.Aimbot_DistanceLimit and distance > library.flags.Aimbot_DistanceLimitValue then
                continue
            end
            
            -- Ignore downed players
            if library.flags.Aimbot_IgnoreDowned and player.Character.Humanoid.Health < 10 then
                continue
            end
            
            local screenPoint, onScreen = Camera:WorldToViewportPoint(player.Character.Head.Position)
            if onScreen then
                local mouseLocation = Vector2.new(Mouse.X, Mouse.Y)
                local playerLocation = Vector2.new(screenPoint.X, screenPoint.Y)
                local distanceToCursor = (mouseLocation - playerLocation).Magnitude
                
                -- FOV check
                if distanceToCursor <= library.flags.Aimbot_FOVSize then
                    -- Distance prioritization
                    if library.flags.Aimbot_DistancePrioritization then
                        if distance < shortestDistance then
                            shortestDistance = distance
                            closestPlayer = player
                        end
                    else
                        if distanceToCursor < shortestDistance then
                            shortestDistance = distanceToCursor
                            closestPlayer = player
                        end
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

local function SmoothAim(targetPosition)
    local currentPosition = Camera.CFrame.Position
    local targetDirection = (targetPosition - currentPosition).Unit
    local currentDirection = Camera.CFrame.LookVector
    
    local smoothness = library.flags.Aimbot_Smoothness / 10
    local smoothedDirection = currentDirection:Lerp(targetDirection, smoothness)
    
    return CFrame_new(currentPosition, currentPosition + smoothedDirection)
end

local function PredictPosition(target, time)
    if not library.flags.Aimbot_Prediction then return target.Position end
    
    local character = target.Parent
    if not character:FindFirstChild("Humanoid") then return target.Position end
    
    local humanoid = character.Humanoid
    local velocity = humanoid.RootPart.Velocity * time
    return target.Position + velocity
end

-- Aimbot Tab
do
    local sections = {
        Main = tabs.Aimbot:AddSection("Main Settings", 1),
        Advanced = tabs.Aimbot:AddSection("Advanced Settings", 2),
        Visual = tabs.Aimbot:AddSection("Visual Settings", 1),
    }

    -- Main Settings
    sections.Main:AddToggle({
        text = "Enable Aimbot",
        flag = "Aimbot_Enabled",
        callback = function(state)
            aimbotActive = state
            library:SendNotification(state and "Aimbot Enabled" or "Aimbot Disabled", 3, state and Color3_fromRGB(0, 255, 0) or Color3_fromRGB(255, 0, 0))
        end
    })

    sections.Main:AddToggle({
        text = "Team Check",
        flag = "Aimbot_TeamCheck",
        tooltip = "Won't target teammates"
    })

    sections.Main:AddToggle({
        text = "Visibility Check",
        flag = "Aimbot_VisibilityCheck",
        tooltip = "Only targets visible players"
    })

    sections.Main:AddToggle({
        text = "Distance Prioritization",
        flag = "Aimbot_DistancePrioritization",
        tooltip = "Prioritizes closest player instead of closest to cursor"
    })

    sections.Main:AddToggle({
        text = "Ignore Downed Players",
        flag = "Aimbot_IgnoreDowned",
        tooltip = "Ignores players with low health"
    })

    sections.Main:AddToggle({
        text = "Distance Limit",
        flag = "Aimbot_DistanceLimit"
    })

    sections.Main:AddSlider({
        text = "Distance Limit Value",
        flag = "Aimbot_DistanceLimitValue",
        suffix = " studs",
        min = 10,
        max = 1000,
        value = 500
    })

    sections.Main:AddList({
        text = "Aim Part",
        flag = "Aimbot_AimPart",
        values = {"Head", "Torso", "HumanoidRootPart", "Random"},
        value = "Head"
    })

    sections.Main:AddBind({
        text = "Aim Key",
        flag = "Aimbot_AimKey",
        mode = "hold",
        bind = Enum.KeyCode.Q
    })

    -- Advanced Settings
    sections.Advanced:AddToggle({
        text = "Silent Aim",
        flag = "Aimbot_SilentAim",
        tooltip = "Makes your bullets hit even when not aiming directly",
        risky = true,
        callback = function(state)
            if state then
                library:SendNotification("Silent Aim Enabled - Use with caution", 5, Color3_fromRGB(255, 165, 0))
            end
        end
    })

    sections.Advanced:AddToggle({
        text = "Triggerbot",
        flag = "Aimbot_Triggerbot",
        tooltip = "Automatically shoots when target is in crosshair"
    })

    sections.Advanced:AddToggle({
        text = "Rage Mode",
        flag = "Aimbot_RageMode",
        tooltip = "Fast snapping instead of smooth aiming"
    })

    sections.Advanced:AddToggle({
        text = "Legit Mode",
        flag = "Aimbot_LegitMode",
        tooltip = "Smooth aiming for more natural movement"
    })

    sections.Advanced:AddToggle({
        text = "Auto Target Swap",
        flag = "Aimbot_AutoTargetSwap",
        tooltip = "Automatically switches to closest target"
    })

    sections.Advanced:AddToggle({
        text = "Manual Lock On",
        flag = "Aimbot_ManualLock",
        tooltip = "Locks onto target until disabled"
    })

    sections.Advanced:AddToggle({
        text = "Wall Check",
        flag = "Aimbot_WallCheck",
        tooltip = "Prevents aiming through walls"
    })

    sections.Advanced:AddToggle({
        text = "Aim Prediction",
        flag = "Aimbot_Prediction",
        tooltip = "Predicts target movement"
    })

    sections.Advanced:AddSlider({
        text = "Prediction Amount",
        flag = "Aimbot_PredictionAmount",
        min = 0.1,
        max = 2,
        value = 0.5
    })

    sections.Advanced:AddSlider({
        text = "Hit Chance %",
        flag = "Aimbot_HitChance",
        suffix = "%",
        min = 0,
        max = 100,
        value = 100
    })

    -- Visual Settings
    sections.Visual:AddToggle({
        text = "Show FOV Circle",
        flag = "Aimbot_ShowFOV",
        callback = function(state)
            drawings.fovCircle.Visible = state
        end
    })

    sections.Visual:AddSlider({
        text = "FOV Size",
        flag = "Aimbot_FOVSize",
        min = 10,
        max = 500,
        value = 100,
        callback = function(value)
            drawings.fovCircle.Radius = value
        end
    })

    sections.Visual:AddColor({
        text = "FOV Color",
        flag = "Aimbot_FOVColor",
        color = Color3_fromRGB(255, 255, 255),
        callback = function(color)
            drawings.fovCircle.Color = color
        end
    })

    sections.Visual:AddSlider({
        text = "FOV Transparency",
        flag = "Aimbot_FOVTransparency",
        min = 0,
        max = 1,
        value = 1,
        increment = 0.1,
        callback = function(value)
            drawings.fovCircle.Transparency = 1 - value
        end
    })

    sections.Visual:AddToggle({
        text = "Draw Aim Target Line",
        flag = "Aimbot_DrawTargetLine"
    })

    sections.Visual:AddColor({
        text = "Target Line Color",
        flag = "Aimbot_TargetLineColor",
        color = Color3_fromRGB(255, 0, 0)
    })

    sections.Visual:AddSlider({
        text = "Smoothness",
        flag = "Aimbot_Smoothness",
        min = 1,
        max = 10,
        value = 5
    })

    -- Aimbot Logic
    local aimbotConnection = RenderStepped:Connect(function()
        if not aimbotActive or not library.flags.Aimbot_Enabled then return end
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
        
        -- Check if aim key is pressed
        local shouldAim = true
        if library.flags.Aimbot_AimKey then
            shouldAim = UserInputService:IsKeyDown(library.flags.Aimbot_AimKey)
        end
        
        if shouldAim then
            -- Get target
            local target = GetClosestPlayerToCursor()
            
            if target and target.Character then
                -- Get aim part
                local aimPartName = library.flags.Aimbot_AimPart
                if aimPartName == "Random" then
                    local parts = {"Head", "Torso", "HumanoidRootPart"}
                    aimPartName = parts[math.random(1, #parts)]
                end
                
                local aimPart = target.Character:FindFirstChild(aimPartName)
                if not aimPart then
                    -- Fallback to head if selected part doesn't exist
                    aimPart = target.Character:FindFirstChild("Head") or target.Character:FindFirstChild("HumanoidRootPart")
                end
                
                if aimPart then
                    -- Prediction
                    local predictionTime = library.flags.Aimbot_PredictionAmount or 0.5
                    local predictedPosition = PredictPosition(aimPart, predictionTime)
                    
                    -- Aim at target
                    if library.flags.Aimbot_RageMode then
                        -- Direct snap
                        Camera.CFrame = CFrame_new(Camera.CFrame.Position, predictedPosition)
                    elseif library.flags.Aimbot_LegitMode then
                        -- Smooth aim
                        Camera.CFrame = SmoothAim(predictedPosition)
                    else
                        -- Default behavior
                        Camera.CFrame = CFrame_new(Camera.CFrame.Position, predictedPosition)
                    end
                end
            end
        end
    end)
    
    table_insert(connections, aimbotConnection)
end

-- Visuals Tab
do
    local sections = {
        ESP = tabs.Visuals:AddSection("ESP Settings", 1),
        Chams = tabs.Visuals:AddSection("Chams & Glow", 2),
        Radar = tabs.Visuals:AddSection("Radar & Overlay", 1),
        Misc = tabs.Visuals:AddSection("Misc Visuals", 2),
    }

    -- ESP Settings
    sections.ESP:AddToggle({
        text = "Enable ESP",
        flag = "ESP_Enabled",
        callback = function(state)
            espEnabled = state
            library:SendNotification(state and "ESP Enabled" or "ESP Disabled", 3, state and Color3_fromRGB(0, 255, 0) or Color3_fromRGB(255, 0, 0))
        end
    })

    sections.ESP:AddToggle({
        text = "Box ESP",
        flag = "ESP_Box"
    })

    sections.ESP:AddToggle({
        text = "Name ESP",
        flag = "ESP_Name"
    })

    sections.ESP:AddToggle({
        text = "Health Bar",
        flag = "ESP_HealthBar"
    })

    sections.ESP:AddToggle({
        text = "Distance Text",
        flag = "ESP_Distance"
    })

    sections.ESP:AddToggle({
        text = "Skeleton ESP",
        flag = "ESP_Skeleton"
    })

    sections.ESP:AddToggle({
        text = "Tracer Lines",
        flag = "ESP_Tracers"
    })

    sections.ESP:AddToggle({
        text = "Head Dot",
        flag = "ESP_HeadDot"
    })

    sections.ESP:AddToggle({
        text = "Weapon ESP",
        flag = "ESP_Weapon"
    })

    sections.ESP:AddToggle({
        text = "Team Color ESP",
        flag = "ESP_TeamColor"
    })

    sections.ESP:AddToggle({
        text = "Rainbow ESP",
        flag = "ESP_Rainbow"
    })

    sections.ESP:AddToggle({
        text = "Out of FOV Arrows",
        flag = "ESP_OOFArrows"
    })

    sections.ESP:AddToggle({
        text = "View Direction Lines",
        flag = "ESP_ViewDirection"
    })

    sections.ESP:AddToggle({
        text = "Distance Limiter",
        flag = "ESP_DistanceLimit"
    })

    sections.ESP:AddSlider({
        text = "Distance Limit",
        flag = "ESP_DistanceLimitValue",
        suffix = " studs",
        min = 10,
        max = 1000,
        value = 500
    })

    sections.ESP:AddToggle({
        text = "Visibility Fade",
        flag = "ESP_VisibilityFade"
    })

    sections.ESP:AddColor({
        text = "ESP Color",
        flag = "ESP_Color",
        color = Color3_fromRGB(255, 255, 255)
    })

    sections.ESP:AddColor({
        text = "Enemy Color",
        flag = "ESP_EnemyColor",
        color = Color3_fromRGB(255, 0, 0)
    })

    sections.ESP:AddColor({
        text = "Team Color",
        flag = "ESP_TeamColorValue",
        color = Color3_fromRGB(0, 255, 0)
    })

    -- Chams & Glow
    sections.Chams:AddToggle({
        text = "Enable Chams",
        flag = "Chams_Enabled",
        callback = function(state)
            library:SendNotification(state and "Chams Enabled" or "Chams Disabled", 3, state and Color3_fromRGB(0, 255, 0) or Color3_fromRGB(255, 0, 0))
        end
    })

    sections.Chams:AddToggle({
        text = "Glow ESP",
        flag = "Chams_Glow"
    })

    sections.Chams:AddToggle({
        text = "Highlight API",
        flag = "Chams_Highlight"
    })

    sections.Chams:AddColor({
        text = "Chams Color",
        flag = "Chams_Color",
        color = Color3_fromRGB(255, 0, 255)
    })

    sections.Chams:AddSlider({
        text = "Chams Transparency",
        flag = "Chams_Transparency",
        min = 0,
        max = 1,
        value = 0.5,
        increment = 0.1
    })

    sections.Chams:AddSlider({
        text = "Glow Intensity",
        flag = "Chams_GlowIntensity",
        min = 0,
        max = 100,
        value = 50
    })

    -- Radar & Overlay
    sections.Radar:AddToggle({
        text = "Enable Radar",
        flag = "Radar_Enabled",
        callback = function(state)
            radarEnabled = state
            library:SendNotification(state and "Radar Enabled" or "Radar Disabled", 3, state and Color3_fromRGB(0, 255, 0) or Color3_fromRGB(255, 0, 0))
        end
    })

    sections.Radar:AddSlider({
        text = "Radar Size",
        flag = "Radar_Size",
        min = 50,
        max = 300,
        value = 150
    })

    sections.Radar:AddSlider({
        text = "Radar Zoom",
        flag = "Radar_Zoom",
        min = 1,
        max = 10,
        value = 3
    })

    sections.Radar:AddToggle({
        text = "Show Names on Radar",
        flag = "Radar_ShowNames"
    })

    sections.Radar:AddToggle({
        text = "Show Health on Radar",
        flag = "Radar_ShowHealth"
    })

    sections.Radar:AddToggle({
        text = "Crosshair Overlay",
        flag = "Crosshair_Enabled",
        callback = function(state)
            crosshairEnabled = state
            for _, line in pairs(drawings.crosshair) do
                line.Visible = state
            end
        end
    })

    sections.Radar:AddColor({
        text = "Crosshair Color",
        flag = "Crosshair_Color",
        color = Color3_fromRGB(255, 255, 255),
        callback = function(color)
            for _, line in pairs(drawings.crosshair) do
                line.Color = color
            end
        end
    })

    sections.Radar:AddSlider({
        text = "Crosshair Size",
        flag = "Crosshair_Size",
        min = 5,
        max = 50,
        value = 15,
        callback = function(value)
            local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            drawings.crosshair.line1.From = center + Vector2.new(-value, 0)
            drawings.crosshair.line1.To = center + Vector2.new(-5, 0)
            drawings.crosshair.line2.From = center + Vector2.new(value, 0)
            drawings.crosshair.line2.To = center + Vector2.new(5, 0)
            drawings.crosshair.line3.From = center + Vector2.new(0, -value)
            drawings.crosshair.line3.To = center + Vector2.new(0, -5)
            drawings.crosshair.line4.From = center + Vector2.new(0, value)
            drawings.crosshair.line4.To = center + Vector2.new(0, 5)
        end
    })

    sections.Radar:AddToggle({
        text = "UI Watermark",
        flag = "UI_Watermark",
        callback = function(state)
            drawings.watermark.Visible = state
        end
    })

    sections.Radar:AddToggle({
        text = "FPS Counter",
        flag = "UI_FPSCounter"
    })

    sections.Radar:AddToggle({
        text = "Ping Counter",
        flag = "UI_PingCounter"
    })

    -- Misc Visuals
    sections.Misc:AddToggle({
        text = "No Fog",
        flag = "Visuals_NoFog",
        callback = function(state)
            if state then
                Lighting.FogEnd = 100000
            else
                Lighting.FogEnd = 1000
            end
        end
    })

    sections.Misc:AddToggle({
        text = "Full Bright",
        flag = "Visuals_FullBright",
        callback = function(state)
            if state then
                Lighting.Ambient = Color3_new(1, 1, 1)
                Lighting.Brightness = 1
            else
                Lighting.Ambient = Color3_new(0.5, 0.5, 0.5)
                Lighting.Brightness = 0.5
            end
        end
    })

    sections.Misc:AddToggle({
        text = "No Sway",
        flag = "Visuals_NoSway"
    })

    sections.Misc:AddToggle({
        text = "No Recoil",
        flag = "Visuals_NoRecoil"
    })

    sections.Misc:AddToggle({
        text = "No Flash",
        flag = "Visuals_NoFlash"
    })

    sections.Misc:AddToggle({
        text = "No Smoke",
        flag = "Visuals_NoSmoke"
    })

    sections.Misc:AddToggle({
        text = "Third Person",
        flag = "Visuals_ThirdPerson",
        callback = function(state)
            if state then
                Camera.CameraType = Enum.CameraType.Scriptable
            else
                Camera.CameraType = Enum.CameraType.Custom
            end
        end
    })

    sections.Misc:AddSlider({
        text = "Third Person Distance",
        flag = "Visuals_ThirdPersonDistance",
        min = 5,
        max = 50,
        value = 10
    })

    sections.Misc:AddButton({
        text = "Save ESP Config",
        callback = function()
            library:SendNotification("ESP Config Saved", 5, Color3_fromRGB(0, 255, 0))
        end
    })

    sections.Misc:AddButton({
        text = "Load ESP Config",
        callback = function()
            library:SendNotification("ESP Config Loaded", 5, Color3_fromRGB(0, 255, 0))
        end
    })

    -- ESP Logic
    local function CreateESP(player)
        if not player or not player.Character then return end
        
        local espData = {
            box = Drawing.new("Square"),
            name = Drawing.new("Text"),
            healthBar = Drawing.new("Square"),
            healthText = Drawing.new("Text"),
            distance = Drawing.new("Text"),
            tracer = Drawing.new("Line"),
            headDot = Drawing.new("Circle"),
            viewAngle = Drawing.new("Line"),
            arrow = Drawing.new("Triangle")
        }
        
        -- Initialize all drawings
        for _, drawing in pairs(espData) do
            drawing.Visible = false
            drawing.ZIndex = 10
        end
        
        -- Configure specific properties
        espData.box.Thickness = 1
        espData.box.Filled = false
        
        espData.name.Size = 16
        espData.name.Center = true
        espData.name.Outline = true
        
        espData.healthBar.Thickness = 1
        espData.healthBar.Filled = true
        
        espData.healthText.Size = 14
        espData.healthText.Outline = true
        
        espData.distance.Size = 14
        espData.distance.Outline = true
        
        espData.tracer.Thickness = 1
        
        espData.headDot.Thickness = 1
        espData.headDot.NumSides = 100
        espData.headDot.Filled = true
        
        espData.viewAngle.Thickness = 1
        
        espData.arrow.Filled = true
        espData.arrow.Thickness = 1
        
        espCache[player] = espData
    end

    local function RemoveESP(player)
        if not espCache[player] then return end
        
        for _, drawing in pairs(espCache[player]) do
            drawing:Remove()
        end
        
        espCache[player] = nil
    end

    local function UpdateESP()
        if not espEnabled or not library.flags.ESP_Enabled then
            for player, _ in pairs(espCache) do
                RemoveESP(player)
            end
            return
        end
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                if not espCache[player] then
                    CreateESP(player)
                end
                
                local espData = espCache[player]
                if not espData then continue end
                
                -- Update all ESP elements
                local character = player.Character
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local head = character:FindFirstChild("Head")
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                
                if not humanoid or not head or not rootPart then
                    for _, drawing in pairs(espData) do
                        drawing.Visible = false
                    end
                    continue
                end
                
                -- Distance check
                local distance = (rootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                if library.flags.ESP_DistanceLimit and distance > library.flags.ESP_DistanceLimitValue then
                    for _, drawing in pairs(espData) do
                        drawing.Visible = false
                    end
                    continue
                end
                
                -- Team check
                local isTeam = player.Team == LocalPlayer.Team
                local color = library.flags.ESP_TeamColor and (isTeam and library.flags.ESP_TeamColorValue or library.flags.ESP_EnemyColor) or library.flags.ESP_Color
                
                if library.flags.ESP_Rainbow then
                    color = Color3.fromHSV(tick() % 5 / 5, 1, 1)
                end
                
                -- Box ESP
                if library.flags.ESP_Box then
                    local headPos, headVis = Camera:WorldToViewportPoint(head.Position)
                    local rootPos = Camera:WorldToViewportPoint(rootPart.Position)
                    
                    if headVis then
                        local height = (headPos.Y - rootPos.Y) * 2
                        local width = height * 0.65
                        
                        espData.box.Position = Vector2.new(rootPos.X - width/2, rootPos.Y - height/2)
                        espData.box.Size = Vector2.new(width, height)
                        espData.box.Color = color
                        espData.box.Visible = true
                    else
                        espData.box.Visible = false
                    end
                else
                    espData.box.Visible = false
                end
                
                -- Name ESP
                if library.flags.ESP_Name then
                    local rootPos, rootVis = Camera:WorldToViewportPoint(rootPart.Position)
                    
                    if rootVis then
                        espData.name.Position = Vector2.new(rootPos.X, rootPos.Y - 40)
                        espData.name.Text = player.Name
                        espData.name.Color = color
                        espData.name.Visible = true
                    else
                        espData.name.Visible = false
                    end
                else
                    espData.name.Visible = false
                end
                
                -- Health Bar
                if library.flags.ESP_HealthBar then
                    local rootPos, rootVis = Camera:WorldToViewportPoint(rootPart.Position)
                    
                    if rootVis then
                        local health = humanoid.Health / humanoid.MaxHealth
                        local height = (espData.box.Size.Y or 50) * health
                        
                        espData.healthBar.Position = Vector2.new(espData.box.Position.X - 8, espData.box.Position.Y + (espData.box.Size.Y - height))
                        espData.healthBar.Size = Vector2.new(2, height)
                        espData.healthBar.Color = Color3.fromRGB(255 * (1 - health), 255 * health, 0)
                        espData.healthBar.Visible = true
                        
                        espData.healthText.Position = Vector2.new(espData.box.Position.X - 15, espData.box.Position.Y - 15)
                        espData.healthText.Text = math_floor(humanoid.Health).."/"..math_floor(humanoid.MaxHealth)
                        espData.healthText.Color = espData.healthBar.Color
                        espData.healthText.Visible = true
                    else
                        espData.healthBar.Visible = false
                        espData.healthText.Visible = false
                    end
                else
                    espData.healthBar.Visible = false
                    espData.healthText.Visible = false
                end
                
                -- Distance Text
                if library.flags.ESP_Distance then
                    local rootPos, rootVis = Camera:WorldToViewportPoint(rootPart.Position)
                    
                    if rootVis then
                        espData.distance.Position = Vector2.new(rootPos.X, rootPos.Y + 5)
                        espData.distance.Text = math_floor(distance).." studs"
                        espData.distance.Color = color
                        espData.distance.Visible = true
                    else
                        espData.distance.Visible = false
                    end
                else
                    espData.distance.Visible = false
                end
                
                -- Tracer Lines
                if library.flags.ESP_Tracers then
                    local rootPos, rootVis = Camera:WorldToViewportPoint(rootPart.Position)
                    
                    if rootVis then
                        espData.tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
                        espData.tracer.To = Vector2.new(rootPos.X, rootPos.Y)
                        espData.tracer.Color = color
                        espData.tracer.Visible = true
                    else
                        espData.tracer.Visible = false
                    end
                else
                    espData.tracer.Visible = false
                end
                
                -- Head Dot
                if library.flags.ESP_HeadDot then
                    local headPos, headVis = Camera:WorldToViewportPoint(head.Position)
                    
                    if headVis then
                        espData.headDot.Position = Vector2.new(headPos.X, headPos.Y)
                        espData.headDot.Radius = 3
                        espData.headDot.Color = color
                        espData.headDot.Visible = true
                    else
                        espData.headDot.Visible = false
                    end
                else
                    espData.headDot.Visible = false
                end
                
                -- View Direction Lines
                if library.flags.ESP_ViewDirection then
                    local rootPos, rootVis = Camera:WorldToViewportPoint(rootPart.Position)
                    
                    if rootVis then
                        local lookDir = rootPart.CFrame.LookVector * 5
                        local endPos = Camera:WorldToViewportPoint(rootPart.Position + lookDir)
                        
                        espData.viewAngle.From = Vector2.new(rootPos.X, rootPos.Y)
                        espData.viewAngle.To = Vector2.new(endPos.X, endPos.Y)
                        espData.viewAngle.Color = color
                        espData.viewAngle.Visible = true
                    else
                        espData.viewAngle.Visible = false
                    end
                else
                    espData.viewAngle.Visible = false
                end
                
                -- Out of FOV Arrows
                if library.flags.ESP_OOFArrows then
                    local rootPos = rootPart.Position
                    local cameraPos = Camera.CFrame.Position
                    local direction = (rootPos - cameraPos).Unit
                    local dot = Camera.CFrame.LookVector:Dot(direction)
                    
                    if dot < 0.5 then -- If player is outside FOV
                        local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
                        local angle = math_atan2(direction.X, direction.Z)
                        local radius = 100
                        
                        local arrowPos = Vector2.new(
                            screenCenter.X + math_cos(angle) * radius,
                            screenCenter.Y + math_sin(angle) * radius
                        )
                        
                        -- Create arrow points
                        local p1 = arrowPos + Vector2.new(math_cos(angle + 0.5) * 15, math_sin(angle + 0.5) * 15)
                        local p2 = arrowPos + Vector2.new(math_cos(angle - 0.5) * 15, math_sin(angle - 0.5) * 15)
                        
                        espData.arrow.PointA = arrowPos
                        espData.arrow.PointB = p1
                        espData.arrow.PointC = p2
                        espData.arrow.Color = color
                        espData.arrow.Visible = true
                    else
                        espData.arrow.Visible = false
                    end
                else
                    espData.arrow.Visible = false
                end
            end
        end
    end

    -- Radar Logic
    local radarCircle = Drawing.new("Circle")
    radarCircle.Visible = false
    radarCircle.Thickness = 1
    radarCircle.Color = Color3_fromRGB(255, 255, 255)
    radarCircle.Filled = false
    radarCircle.Transparency = 1
    radarCircle.Radius = 75
    radarCircle.Position = Vector2.new(100, 100)

    local radarCenter = Drawing.new("Circle")
    radarCenter.Visible = false
    radarCenter.Thickness = 1
    radarCenter.Color = Color3_fromRGB(255, 0, 0)
    radarCenter.Filled = true
    radarCenter.Transparency = 1
    radarCenter.Radius = 3
    radarCenter.Position = Vector2.new(100, 100)

    local radarBlips = {}

    local function UpdateRadar()
        if not radarEnabled or not library.flags.Radar_Enabled then
            radarCircle.Visible = false
            radarCenter.Visible = false
            
            for _, blip in pairs(radarBlips) do
                blip:Remove()
            end
            radarBlips = {}
            return
        end
        
        radarCircle.Visible = true
        radarCenter.Visible = true
        radarCircle.Radius = library.flags.Radar_Size or 75
        
        -- Clear old blips
        for _, blip in pairs(radarBlips) do
            blip:Remove()
        end
        radarBlips = {}
        
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
        
        local localPos = LocalPlayer.Character.HumanoidRootPart.Position
        local localCFrame = Camera.CFrame
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local rootPart = player.Character.HumanoidRootPart
                local direction = (rootPart.Position - localPos) * Vector3_new(1, 0, 1)
                local relativePos = localCFrame:PointToObjectSpace(localPos + direction)
                
                -- Normalize and scale to radar size
                local zoom = library.flags.Radar_Zoom or 3
                local normalizedPos = Vector2.new(
                    -relativePos.X / (50 * zoom),
                    -relativePos.Z / (50 * zoom)
                )
                
                -- Clamp to radar circle
                local length = math_sqrt(normalizedPos.X^2 + normalizedPos.Y^2)
                if length > 1 then
                    normalizedPos = normalizedPos / length
                end
                
                -- Create blip
                local blip = Drawing.new("Circle")
                blip.Visible = true
                blip.Thickness = 1
                blip.Color = player.Team == LocalPlayer.Team and library.flags.ESP_TeamColorValue or library.flags.ESP_EnemyColor
                blip.Filled = true
                blip.Transparency = 1
                blip.Radius = 4
                blip.Position = radarCircle.Position + (normalizedPos * radarCircle.Radius)
                
                -- Add name if enabled
                if library.flags.Radar_ShowNames then
                    local nameText = Drawing.new("Text")
                    nameText.Visible = true
                    nameText.Size = 12
                    nameText.Color = blip.Color
                    nameText.Outline = true
                    nameText.Text = player.Name
                    nameText.Position = blip.Position + Vector2.new(0, 10)
                    
                    table_insert(radarBlips, nameText)
                end
                
                table_insert(radarBlips, blip)
            end
        end
    end

    -- Crosshair Logic
    local function UpdateCrosshair()
        if not crosshairEnabled or not library.flags.Crosshair_Enabled then return end
        
        local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        local size = library.flags.Crosshair_Size or 15
        
        drawings.crosshair.line1.From = center + Vector2.new(-size, 0)
        drawings.crosshair.line1.To = center + Vector2.new(-5, 0)
        drawings.crosshair.line2.From = center + Vector2.new(size, 0)
        drawings.crosshair.line2.To = center + Vector2.new(5, 0)
        drawings.crosshair.line3.From = center + Vector2.new(0, -size)
        drawings.crosshair.line3.To = center + Vector2.new(0, -5)
        drawings.crosshair.line4.From = center + Vector2.new(0, size)
        drawings.crosshair.line4.To = center + Vector2.new(0, 5)
    end

    -- FPS Counter
    local function UpdateFPS()
        frameCount = frameCount + 1
        
        if tick() - lastTick >= 1 then
            fps = math_floor(frameCount / (tick() - lastTick))
            frameCount = 0
            lastTick = tick()
            
            if drawings.watermark then
                drawings.watermark.Text = "Stratus.xyz | "..(identifyexecutor() or "Unknown").." | FPS: "..fps
            end
        end
    end

    -- Main Visuals Loop
    local visualsConnection = RenderStepped:Connect(function()
        UpdateESP()
        UpdateRadar()
        UpdateCrosshair()
        UpdateFPS()
    end)
    
    table_insert(connections, visualsConnection)
    
    -- Player Added/Removed Events
    local function PlayerAdded(player)
        CreateESP(player)
    end

    local function PlayerRemoving(player)
        RemoveESP(player)
    end

    Players.PlayerAdded:Connect(PlayerAdded)
    Players.PlayerRemoving:Connect(PlayerRemoving)
    
    -- Initialize ESP for existing players
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            CreateESP(player)
        end
    end
end

-- Risky Tab
do
    local sections = {
        Main = tabs.Risky:AddSection("Risky Features", 1),
        AntiCheat = tabs.Risky:AddSection("Anti-Cheat Bypass", 2),
    }

    -- Main Features
    sections.Main:AddToggle({
        text = "Fly Hack",
        flag = "Risky_Fly",
        risky = true,
        tooltip = "Allows you to fly around the map",
        callback = function(state)
            if state then
                library:SendNotification("Warning: Fly hack is highly detectable!", 5, Color3_fromRGB(255, 0, 0))
                
                local bodyVelocity = Instance_new("BodyVelocity")
                bodyVelocity.Velocity = Vector3_new(0, 0, 0)
                bodyVelocity.MaxForce = Vector3_new(0, math.huge, 0)
                bodyVelocity.Parent = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                
                local flyConnection
                flyConnection = Stepped:Connect(function()
                    if not library.flags.Risky_Fly or not LocalPlayer.Character then
                        bodyVelocity:Destroy()
                        flyConnection:Disconnect()
                        return
                    end
                    
                    local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if not rootPart then return end
                    
                    local velocity = rootPart.Velocity
                    velocity = Vector3_new(0, velocity.Y, 0)
                    
                    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                        velocity = velocity + Vector3_new(0, 50, 0)
                    elseif UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
                        velocity = velocity + Vector3_new(0, -50, 0)
                    end
                    
                    bodyVelocity.Velocity = velocity
                end)
                
                table_insert(connections, flyConnection)
            end
        end
    })

    sections.Main:AddToggle({
        text = "Speed Hack",
        flag = "Risky_Speed",
        risky = true,
        tooltip = "Increases your movement speed",
        callback = function(state)
            if state then
                library:SendNotification("Warning: Speed hack is detectable!", 5, Color3_fromRGB(255, 0, 0))
                
                local speedConnection
                speedConnection = Stepped:Connect(function()
                    if not library.flags.Risky_Speed or not LocalPlayer.Character then
                        speedConnection:Disconnect()
                        return
                    end
                    
                    local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid.WalkSpeed = 32 -- Default is 16
                    end
                end)
                
                table_insert(connections, speedConnection)
            else
                if LocalPlayer.Character then
                    local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid.WalkSpeed = 16
                    end
                end
            end
        end
    })

    sections.Main:AddToggle({
        text = "Kill Aura",
        flag = "Risky_KillAura",
        risky = true,
        tooltip = "Automatically attacks nearby players",
        callback = function(state)
            if state then
                library:SendNotification("Warning: Kill aura is very detectable!", 5, Color3_fromRGB(255, 0, 0))
                
                local killAuraConnection
                killAuraConnection = Heartbeat:Connect(function()
                    if not library.flags.Risky_KillAura or not LocalPlayer.Character then
                        killAuraConnection:Disconnect()
                        return
                    end
                    
                    local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if not rootPart then return end
                    
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and player.Character then
                            local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                            if targetRoot and (targetRoot.Position - rootPart.Position).Magnitude < 20 then
                                -- Simulate attack (actual implementation would vary by game)
                                local args = {
                                    [1] = player.Character:FindFirstChild("Head") or targetRoot,
                                    [2] = 100
                                }
                                
                                local success, err = pcall(function()
                                    game:GetService("ReplicatedStorage").Events.Damage:FireServer(unpack(args))
                                end)
                                
                                if not success then
                                    warn("KillAura Error:", err)
                                end
                            end
                        end
                    end
                end)
                
                table_insert(connections, killAuraConnection)
            end
        end
    })

    sections.Main:AddButton({
        text = "Teleport To Player",
        risky = true,
        confirm = true,
        callback = function()
            library:SendNotification("Select a player to teleport to", 5, Color3_fromRGB(255, 255, 0))
            
            local target = nil
            local closestDistance = math.huge
            
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance < closestDistance then
                        closestDistance = distance
                        target = player
                    end
                end
            end
            
            if target then
                LocalPlayer.Character.HumanoidRootPart.CFrame = target.Character.HumanoidRootPart.CFrame
                library:SendNotification("Teleported to "..target.Name, 5, Color3_fromRGB(0, 255, 0))
            else
                library:SendNotification("No valid target found", 5, Color3_fromRGB(255, 0, 0))
            end
        end
    })

    -- Anti-Cheat Bypass
    sections.AntiCheat:AddToggle({
        text = "Hook Anti-Cheat",
        flag = "Risky_HookAC",
        risky = true,
        tooltip = "Attempts to bypass anti-cheat (may crash)",
        callback = function(state)
            if state then
                library:SendNotification("Warning: This may crash your game!", 10, Color3_fromRGB(255, 0, 0))
                
                -- Simulate anti-cheat bypass (actual implementation would vary)
                local oldNamecall
                oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
                    local method = getnamecallmethod()
                    
                    -- Bypass common anti-cheat checks
                    if method == "Kick" or method == "kick" then
                        return nil
                    elseif method == "IsA" and tostring(self) == "AntiCheat" then
                        return false
                    end
                    
                    return oldNamecall(self, ...)
                end)
                
                -- Store for cleanup
                getgenv().ACBypassHook = oldNamecall
            else
                -- Restore original function
                if getgenv().ACBypassHook then
                    hookmetamethod(game, "__namecall", getgenv().ACBypassHook)
                    getgenv().ACBypassHook = nil
                end
            end
        end
    })

    sections.AntiCheat:AddToggle({
        text = "No Clip",
        flag = "Risky_NoClip",
        risky = true,
        tooltip = "Walk through walls",
        callback = function(state)
            if state then
                library:SendNotification("No Clip Enabled", 5, Color3_fromRGB(255, 255, 0))
                
                local noclipConnection
                noclipConnection = Stepped:Connect(function()
                    if not library.flags.Risky_NoClip or not LocalPlayer.Character then
                        noclipConnection:Disconnect()
                        return
                    end
                    
                    for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end)
                
                table_insert(connections, noclipConnection)
            end
        end
    })

    sections.AntiCheat:AddToggle({
        text = "Infinite Jump",
        flag = "Risky_InfiniteJump",
        risky = true,
        tooltip = "Jump infinitely in the air",
        callback = function(state)
            if state then
                library:SendNotification("Infinite Jump Enabled", 5, Color3_fromRGB(255, 255, 0))
                
                local infiniteJumpConnection
                infiniteJumpConnection = UserInputService.JumpRequest:Connect(function()
                    if library.flags.Risky_InfiniteJump and LocalPlayer.Character then
                        LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping")
                    end
                end)
                
                table_insert(connections, infiniteJumpConnection)
            end
        end
    })

    sections.AntiCheat:AddButton({
        text = "Unload Script",
        callback = function()
            library:Unload()
        end
    })
end

-- Settings Tab
do
    -- Config Saving/Loading
    local function SaveConfig()
        local config = {}
        
        -- Save all flags
        for flag, value in pairs(library.flags) do
            config[flag] = value
        end
        
        getgenv().Config.Settings = config
        library:SendNotification("Config Saved", 3, Color3_fromRGB(0, 255, 0))
    end

    local function LoadConfig()
        if not getgenv().Config.Settings then return end
        
        for flag, value in pairs(getgenv().Config.Settings) do
            if library.flags[flag] ~= nil then
                library.options[flag]:SetValue(value)
            end
        end
        
        library:SendNotification("Config Loaded", 3, Color3_fromRGB(0, 255, 0))
    end

    local function ResetConfig()
        for flag, _ in pairs(library.flags) do
            if library.options[flag] and library.options[flag].default then
                library.options[flag]:SetValue(library.options[flag].default)
            end
        end
        
        library:SendNotification("Config Reset", 3, Color3_fromRGB(0, 255, 0))
    end

    tabs.Settings:AddButton({
        text = "Save Config",
        callback = SaveConfig
    })

    tabs.Settings:AddButton({
        text = "Load Config",
        callback = LoadConfig
    })

    tabs.Settings:AddButton({
        text = "Reset Config",
        callback = ResetConfig
    })
end

-- Cleanup on script termination
local function Cleanup()
    for _, connection in pairs(connections) do
        connection:Disconnect()
    end
    
    -- Remove all drawings
    for _, drawing in pairs(drawings) do
        if typeof(drawing) == "table" then
            for _, d in pairs(drawing) do
                if d and d.Remove then
                    d:Remove()
                end
            end
        elseif drawing and drawing.Remove then
            drawing:Remove()
        end
    end
    
    -- Remove ESP
    for player, _ in pairs(espCache) do
        RemoveESP(player)
    end
    
    -- Remove radar blips
    for _, blip in pairs(radarBlips) do
        blip:Remove()
    end
end

-- Auto-execute
library:SendNotification("Stratus.xyz Arsenal Premium Loaded!", 5, Color3_fromRGB(0, 255, 0))

-- Load config if exists
if getgenv().Config.Settings then
    LoadConfig()
end

-- Cleanup on game close or script termination
game:BindToClose(Cleanup)
LocalPlayer.OnTeleport:Connect(Cleanup)

-- Keep script running
while true do
    task.wait(1)
end
